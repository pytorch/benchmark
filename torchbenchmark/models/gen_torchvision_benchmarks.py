import os
from pathlib import Path

def gen_classification_template(model):
    input_shape = (32, 3, 224, 224)
    classification_template = f"""
# Generated by gen_torchvision_benchmark.py
import torch
import torch.optim as optim
import torchvision.models as models

class Model:
    def __init__(self, device="cpu", jit=False):
        self.device = device
        self.jit = jit
        self.model = models.{model}()
        if self.jit:
            self.model = torch.jit.script(self.model)
        self.example_inputs = (torch.randn({input_shape}),)

    def get_module(self):
        return self.model, self.example_inputs

    def train(self, niter=3):
        self.model.train()
        optimizer = optim.Adam(self.model.parameters())
        loss = torch.nn.CrossEntropyLoss()
        for _ in range(niter):
            optimizer.zero_grad()
            pred = self.model(*self.example_inputs)
            y = torch.empty(pred.shape[0], dtype=torch.long).random_(pred.shape[1])
            loss(pred, y).backward()
            optimizer.step()

    def eval(self, niter=1):
        self.model.eval()
        model, example_inputs = self.get_module()
        example_inputs = example_inputs[0][0].unsqueeze(0)
        for i in range(niter):
            model(example_inputs)

if __name__ == "__main__":
    m = Model(device="cuda", jit=True)
    module, example_inputs = m.get_module()
    module(*example_inputs)
    m.train(niter=1)
    m.eval(niter=1)
"""
    return classification_template

def gen_segmentation_template(model):
    input_shape = (32, 3, 224, 224)
    program_template = f"""
# Generated by gen_torchvision_benchmark.py
import torch
import torch.optim as optim
import torchvision.models.segmentation as models

class Model:
    def __init__(self, device="cpu", jit=False):
        self.device = device
        self.jit = jit
        self.model = models.{model}(pretrained_backbone=False)
        if self.jit:
            self.model = torch.jit.script(self.model)
        self.example_inputs = (torch.randn({input_shape}),)

    def get_module(self):
        return self.model, self.example_inputs

    def train(self, niter=3):
        self.model.train()
        optimizer = optim.Adam(self.model.parameters())
        loss = torch.nn.CrossEntropyLoss()
        for _ in range(niter):
            optimizer.zero_grad()
            pred = self.model(*self.example_inputs)
            y = torch.empty(pred['out'].shape, dtype=torch.long).sum(dim=1).random_(pred['out'].shape[1])
            loss(pred['out'], y).backward()
            optimizer.step()

    def eval(self, niter=1):
        self.model.eval()
        model, example_inputs = self.get_module()
        example_inputs = example_inputs[0][0].unsqueeze(0)
        for i in range(niter):
            model(example_inputs)

if __name__ == "__main__":
    m = Model(device="cuda", jit=True)
    module, example_inputs = m.get_module()
    module(*example_inputs)
    m.train(niter=1)
    m.eval(niter=1)
"""
    return program_template

class_models = ['alexnet', 'vgg16', 'resnet18', 'resnet50', 'squeezenet1_1', 'densenet121', 'mobilenet_v2', 'shufflenet_v2_x1_0', 'resnext50_32x4d', 'mnasnet1_0']
for model in class_models:
    folder = Path(model)
    if not os.path.isdir(folder):
        os.makedirs(folder)
    init_program = gen_classification_template(model)
    with open(folder / '__init__.py', 'w') as f:
        f.write(init_program)
    with open(folder / 'install.py', 'w') as f:
        pass
    
segmentation_models = ['fcn_resnet50', 'deeplabv3_resnet101']
for model in segmentation_models:
    folder = Path(model)
    if not os.path.isdir(folder):
        os.makedirs(folder)
    init_program = gen_segmentation_template(model)
    with open(folder / '__init__.py', 'w') as f:
        f.write(init_program)
    with open(folder / 'install.py', 'w') as f:
        pass