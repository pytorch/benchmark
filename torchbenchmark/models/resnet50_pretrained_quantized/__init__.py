
# Generated by gen_torchvision_benchmark.py
import torch
import torchvision.models.quantization as models
from ...util.model import BenchmarkModel
from torchbenchmark.tasks import COMPUTER_VISION

#######################################################
#
#       DO NOT MODIFY THESE FILES DIRECTLY!!!
#       USE `gen_torchvision_benchmarks.py`
#
#######################################################
class Model(BenchmarkModel):
    task = COMPUTER_VISION.CLASSIFICATION
    optimized_for_inference = True
    def __init__(self, device=None, jit=False):
        super().__init__()
        self.device = device
        self.jit = jit
        self.model = models.resnet50(pretrained=True, quantize=True).to(self.device)
        self.eval_model = models.resnet50(pretrained=True, quantize=True).to(self.device)
        self.example_inputs = (torch.randn((32, 3, 224, 224)).to(self.device),)

        if self.jit:
            self.model = torch.jit._script_pdt(self.model, example_inputs=[self.example_inputs, ])
            self.eval_model = torch.jit.script(self.eval_model)
            # model needs to in `eval`
            # in order to be optimized for inference
            self.eval_model.eval()
            self.eval_model = torch.jit.optimize_for_inference(self.eval_model)


    def get_module(self):
        return self.model, self.example_inputs

    # vision models have another model
    # instance for inference that has
    # already been optimized for inference
    def set_eval(self):
        pass

    # pre-trained model
    def train(self, niter=3):
        pass

    def eval(self, niter=1):
        if self.device != 'cpu':
            raise NotImplementedError()
        model, example_inputs = self.get_module()
        example_inputs = example_inputs[0][0].unsqueeze(0)
        for _i in range(niter):
            model(example_inputs)


if __name__ == "__main__":
    m = Model(device="cpu", jit=True)
    module, example_inputs = m.get_module()
    module(*example_inputs)
    m.train(niter=1)
    m.eval(niter=1)
